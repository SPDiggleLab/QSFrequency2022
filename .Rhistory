source('~/CYZ GITHUB/Digglets/For_Conan/MASTER_IPCD-analysis.R')
df.truncations
test = df.truncations
rownames(df.truncations) = NULL
df.truncations
write.table(df.truncations, file = '2021_06_03-Truncs.csv', sep=',', row.names = F)
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
gene
# NUCLEOTIDE ANALYSIS
source('nucleotide.R')
source('process_inputs.R')
source('parse_metadata.R')
source('parse_inputs.R')
rm(list=ls())
## 04.11.2020 - CYZ
## This script loads all lab inputs and creates a master input data file.
## The entries in the data are quality controlled:
## -- Sequences must have START codon.
#  (0) Helpers ------------------------------------------------------------
Fix_Known_Database_Discrepancies = function(strains){
# Some of the entries in the IPCD database online dont' agree with what's keyed in NCBI.
# This is a correction of what I noticed were some mismatches.
ret = strains
ret = as.vector(gsub('MCF', 'AL', ret))
return(ret)
}
# (1) Second Method -------------------------------------------------------
# Idea: Should be gene-focused. For each gene, add on the metadata information for the gene.
temp.ls_out = list()
# alternate labs
df.lab_strain_meta = read.table('INPUT/strain_meta.tsv', sep='\t', header = T, stringsAsFactors = F)
# if there are query duplicates, remove both.
v.duplicates = df.lab_strain_meta$STRAIN_ID[duplicated(df.lab_strain_meta$STRAIN_ID)]
df.lab_strain_meta = df.lab_strain_meta[!(df.lab_strain_meta$STRAIN_ID %in% v.duplicates),]
# Extract gene information
gene_files = list.files('INPUT/genes/', pattern='.tsv')
for(genefile in gene_files){
gene = strsplit(genefile, '_')[[1]][1]
temp.in = read.table(paste('INPUT/genes/', genefile, sep='', collapse=''), header=T, stringsAsFactors=F)
# there are duplicate entries for fragments
temp.in$INFO[duplicated(temp.in$INFO)] = paste(temp.in$INFO[duplicated(temp.in$INFO)], '_frag', sep='')
rownames(temp.in) = temp.in$INFO
# raw_strain corrections: word 'strain' missing from info
b.no_strain = !grepl('Pseudomonas aeruginosa strain', temp.in$INFO)
temp.in$INFO[b.no_strain] = gsub('Pseudomonas aeruginosa', 'Pseudomonas aeruginosa strain', temp.in$INFO[b.no_strain])
# Parse INFO for strain name
raw_strains = temp.in$INFO
# Obtain lab-reported strain ID
parsed_strains = sapply(raw_strains, function(x){
if(grepl('isolate', x)){
split1 = strsplit(x, 'isolate ')[[1]][2]
split2 = strsplit(split1, ' IPC')[[1]][1]
}else{
split1 = strsplit(x, 'strain ')[[1]][2]
split2 = strsplit(split1, ' IPC')[[1]][1]
}
return(split2)
})
# Obtain NCBI ID
alt_strain_id = sapply(raw_strains, function(x){
split1 = strsplit(x, ' ')[[1]][1]
return(split1)
})
# Obtain IPC ID
IPCD_strain_id = sapply(raw_strains, function(x){
split1 = strsplit(x, ',')[[1]][1]
split2 = strsplit(split1, ' IPC')[[1]][2]
return(paste('IPC', split2, sep='', collapse=''))
})
# Some parsed_strains have issues as well; this is a manual rule application
fixed_strains = Fix_Known_Database_Discrepancies(parsed_strains)
# Create a summary df for debugging
df.strains_ref_by_gene = data.frame('STRAIN' = fixed_strains
, 'ALT_ID' = alt_strain_id
, 'IPCD_ID' = IPCD_strain_id
, 'GENE' = gene
, 'raw_ID' = raw_strains
, 'parsed_ID' = parsed_strains
, stringsAsFactors = F)
rownames(df.strains_ref_by_gene) = df.strains_ref_by_gene$raw_ID
# Combine
temp.in = cbind(temp.in, df.strains_ref_by_gene[temp.in$INFO, c('STRAIN', 'ALT_ID', 'IPCD_ID', 'GENE')])
# Setup new columns for combination
temp.in[,colnames(df.lab_strain_meta)] = NA
errlist = cbind('gene' = rep(NA, nrow(temp.in)), 'errtype' = rep(NA, nrow(temp.in)))
# query lab_strain_meta the careful way
for(i in 1:nrow(temp.in)){
# Expect only one query per temp.in entry
i_strain = temp.in[i,'STRAIN']
b.strain_meta = (df.lab_strain_meta$STRAIN_ID == i_strain)
# If no exact match, use grep to identify single entry with closest match
if(sum(b.strain_meta)==0){
b.strain_meta = grepl(i_strain, df.lab_strain_meta$STRAIN_ID)
errlist[i,] = c(i_strain, 'grepl used')
}
if(sum(b.strain_meta)== 1){
temp.in[i,colnames(df.lab_strain_meta)] = df.lab_strain_meta[b.strain_meta,]
}else{
errlist[i,] = c(i_strain, 'multi-hit')
}
}
# Save info
temp.ls_out[[gene]] = temp.in
}
df.masterList = do.call('rbind', temp.ls_out)
# output
write.csv(df.masterList,  paste('OUTPUT/',Sys.Date(), '_master-table.csv', sep='', collapse=''), row.names = F, na = '')
genefile
gene = strsplit(genefile, '_')[[1]][1]
temp.in = read.table(paste('INPUT/genes/', genefile, sep='', collapse=''), header=T, stringsAsFactors=F)
genefile
test = read.table(genefile)
test = read.table(paste('gene/', genefile, sep='', collapse=''))
test = read.table(paste('genes/', genefile, sep='', collapse=''))
test = read.table(paste('INPUT/genes/', genefile, sep='', collapse=''))
test = read.table(paste('INPUT/genes/', genefile, sep='', collapse=''), sep='\t')
test
ncol(test)
colnames(test) ="INFO"	"SEQUENCE"	"MISMATCH"	"GAPS"	"PCT_ID"	"QUERY_COV"	"BIT_SCORE"	"E-VALUE"
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
headD(test)
test
write.table(test, 'test.tsv', sep='\t')
write.table(test, 'test.tsv', sep='\t', row.names = F)
genefile
test = read.table(paste('INPUT/genes/', 'rpoA_seqs_from_IPCD.tsv', sep='', collapse=''), sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
write.table(test, 'test.tsv', sep='\t')
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
gene
test = read.csv('INPUT/genes/rsaL_matches.tsv')
head(test)
head(test)
head(test)
test = read.csv('INPUT/genes/rsaL_matches.tsv', col.names = F)
test
head(test)
test = read.csv('INPUT/genes/rsaL_matches.tsv', header = F)
head(test)
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
ncol(test)
test = read.table('INPUT/genes/rsaL_matches.tsv', header = F)
test = read.table('INPUT/genes/rsaL_matches.tsv', header = F, sep='\t')
head(test)
test = read.table('INPUT/genes/rsaL_matches.tsv', header = F, sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
test = read.table('INPUT/genes/rsaL_matches.tsv'
, header = F
, sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
write.table(test, file = 'INPUT/genes/rsaL_seqs_from_IPCD.tsv'
, sep='\t'
, quote = T
, row.names = F
, col.names = T)
test = read.table('INPUT/genes/rsmA_matches.tsv'
, header = F
, sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
write.table(test, file = 'INPUT/genes/rsmA_seqs_from_IPCD.tsv'
, sep='\t'
, quote = T
, row.names = F
, col.names = T)
test = read.table('INPUT/genes/mucA_seqs_from_IPCD.tsv'
, header = F
, sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
write.table(test, file = 'INPUT/genes/mucA_seqs_from_IPCD.tsv'
, sep='\t'
, quote = T
, row.names = F
, col.names = T)
test = read.table('INPUT/genes/rpoA_seqs_from_IPCD.tsv'
, header = F
, sep='\t')
colnames(test) = c("INFO",	"SEQUENCE",	"MISMATCH",	"GAPS",	"PCT_ID",	"QUERY_COV",	"BIT_SCORE",	"E-VALUE")
write.table(test, file = 'INPUT/genes/rpoA_seqs_from_IPCD.tsv'
, sep='\t'
, quote = T
, row.names = F
, col.names = T)
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
df.lasR_meta
df.truncations
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
gene
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
# NUCLEOTIDE ANALYSIS
source('nucleotide.R')
source('process_inputs.R')
source('parse_metadata.R')
source('parse_inputs.R')
gene_files
View(df.masterList)
unique(df.masterList$GENE)
table(df.masterList$GENE)
source('analyze_seqs.R')
rm(list=ls())
require(Biostrings)
require(factoextra)
require(ape)
require(vegan)
TRUNCATION_CUTOFF = 0 #0 for all data. 1 for no truncations allowed.
ALIGN_VS_REF_BIOSTRING = function(REF=lasI_ref, ALL=lasI_all, gapOpen=11, gapExt=1){
ret = lapply(ALL, function(x){
return (pairwiseAlignment(REF
, x
, substitutionMatrix = "BLOSUM80"
, gapOpening=gapOpen
, gapExtension=gapExt)@score)
})
ret = do.call('rbind', ret)
return(ret)
}#test_ALIGN_VS_REF_BIOSTRING = ALIGN_VS_REF_BIOSTRING(ls.aastring_map[[1]], ls.aastring_map)
ALIGN_VS_SELF_BIOSTRING = function(ALL=lasI_all){
# to strings
v.seqs = unlist(lapply(ALL, as.character)) # char
v.seq_nos = names(ALL) # char
names(v.seqs) = v.seq_nos
nSeqs = length(v.seqs)
# find uniques
v.unique_seqs = v.seqs[!duplicated(v.seqs)]
# Reduce to unique AA sequences
ls_unique_seqs = ALL[names(v.unique_seqs)] # WARNING: the 'unique' function doesn't work with lists
# Calculate distances on AA sequences BIOSTRINGS
ls.uniqueAADist = lapply(ls_unique_seqs, function(x){
ret = ALIGN_VS_REF_BIOSTRING(x, ls_unique_seqs)
})
# Format distance matrix of unique AA sequences
df.uniqueAADist = do.call('cbind', ls.uniqueAADist)
colnames(df.uniqueAADist) = v.unique_seqs
rownames(df.uniqueAADist) = v.unique_seqs
# Format distance matrix of unique NT sequences
df.fullAADist = data.frame(matrix(rep(0, nSeqs^2), ncol = nSeqs))
colnames(df.fullAADist) = v.seq_nos
rownames(df.fullAADist) = v.seq_nos
# Fill distance matrix of unique NT sequences
for(i in 1:nSeqs){
for(j in 1:nSeqs){
i.seq = v.seqs[v.seq_nos[i]]
j.seq = v.seqs[v.seq_nos[j]]
if(!j.seq %in% v.unique_seqs){
print(j.seq)
}
df.fullAADist[i,j] = df.uniqueAADist[i.seq, j.seq]
}
}
return(df.fullAADist)
} #test_ALIGN_VS_SELF_BIOSTRING = ALIGN_VS_SELF_BIOSTRING(ls.aastring_map)
# Get truncation statistics
if(!file.exists('OBJECTS/gene_trunc_stats.R')){
# Find the most recent master table file
temp.fileList = list.files('OUTPUT/')
temp.fileDirs = temp.fileList[grep('_master-table.csv', temp.fileList)]
temp.fileDir = sort(temp.fileDirs, decreasing = T)[1]
# Read in sequence master table
df.in = read.table(paste('OUTPUT/', temp.fileDir, sep=''), header = T, sep=',', stringsAsFactors = F)
df.in = df.in[,c('STRAIN', 'GENE', 'HOST', 'SOURCE', 'ENV', 'PI'
, 'SEQUENCE' , 'MISMATCH', 'GAPS', 'PCT_ID', 'QUERY_COV', 'BIT_SCORE', 'E.VALUE'
, 'INCLUDE')]
rm(temp.fileList, temp.fileDirs, temp.fileDir)
# Fill in Blanks
df.in[df.in==''] = NA
# Split by gene
ls.in = split(df.in, df.in$GENE)
ls.truncations = list()
ls.complete_gene_MetaSeq = list()
for(gene in names(ls.in)){
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
v.gene_lens = sapply(df.gene$SEQUENCE, function(x){nchar(x)})
b.ref_length_passed_cutoff = (v.gene_lens > TRUNCATION_CUTOFF*gene_length) # how many genes were longer than TRUNCATION_CUTOFF * gene_length?
n.trunc = sum(!b.ref_length_passed_cutoff)
mean_length = mean(v.gene_lens)
# Remove
df.gene = df.gene[b.ref_length_passed_cutoff,]
# Get number of
ls.truncations[[gene]] = c('gene' = gene
, 'n_base' = gene_length
, 'n_allGenes' = n.allGenes
, 'n_genes' = n.genes
, 'n_unique_strains' = n.unique_strains
, 'n_unique_seqs' = n.unique_sequences
, 'p_incomplete' = (n.trunc+n.gaps)/n.genes
, 'mean_len' = mean_length/gene_length) # save stats
ls.complete_gene_MetaSeq[[gene]] = df.gene # save t
}
df.truncations = data.frame(do.call('rbind', ls.truncations), stringsAsFactors = F)
df.truncations[,-1] = apply(df.truncations[,-1], 2, as.numeric) # fix datatype
write.csv(df.truncations, file = 'OUTPUT/gene_truncated_stats.csv')
save(ls.complete_gene_MetaSeq
, df.truncations
, TRUNCATION_CUTOFF
, ALIGN_VS_REF_BIOSTRING
, ALIGN_VS_SELF_BIOSTRING
, file='OBJECTS/gene_trunc_stats.R')
}else{
load('OBJECTS/gene_trunc_stats.R')
}
temp.fileDir
temp.fileList
!file.exists('OBJECTS/gene_trunc_stats.R')
# Find the most recent master table file
temp.fileList = list.files('OUTPUT/')
temp.fileDirs = temp.fileList[grep('_master-table.csv', temp.fileList)]
# Get truncation statistics
if(!file.exists('OBJECTS/gene_trunc_stats.R')){
# Find the most recent master table file
temp.fileList = list.files('OUTPUT/')
temp.fileDirs = temp.fileList[grep('_master-table.csv', temp.fileList)]
temp.fileDir = sort(temp.fileDirs, decreasing = T)[1]
# Read in sequence master table
df.in = read.table(paste('OUTPUT/', temp.fileDir, sep=''), header = T, sep=',', stringsAsFactors = F)
df.in = df.in[,c('STRAIN', 'GENE', 'HOST', 'SOURCE', 'ENV', 'PI'
, 'SEQUENCE' , 'MISMATCH', 'GAPS', 'PCT_ID', 'QUERY_COV', 'BIT_SCORE', 'E.VALUE'
, 'INCLUDE')]
rm(temp.fileList, temp.fileDirs, temp.fileDir)
# Fill in Blanks
df.in[df.in==''] = NA
# Split by gene
ls.in = split(df.in, df.in$GENE)
ls.truncations = list()
ls.complete_gene_MetaSeq = list()
for(gene in names(ls.in)){
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
v.gene_lens = sapply(df.gene$SEQUENCE, function(x){nchar(x)})
b.ref_length_passed_cutoff = (v.gene_lens > TRUNCATION_CUTOFF*gene_length) # how many genes were longer than TRUNCATION_CUTOFF * gene_length?
n.trunc = sum(!b.ref_length_passed_cutoff)
mean_length = mean(v.gene_lens)
# Remove
df.gene = df.gene[b.ref_length_passed_cutoff,]
# Get number of
ls.truncations[[gene]] = c('gene' = gene
, 'n_base' = gene_length
, 'n_allGenes' = n.allGenes
, 'n_genes' = n.genes
, 'n_unique_strains' = n.unique_strains
, 'n_unique_seqs' = n.unique_sequences
, 'p_incomplete' = (n.trunc+n.gaps)/n.genes
, 'mean_len' = mean_length/gene_length) # save stats
ls.complete_gene_MetaSeq[[gene]] = df.gene # save t
}
df.truncations = data.frame(do.call('rbind', ls.truncations), stringsAsFactors = F)
df.truncations[,-1] = apply(df.truncations[,-1], 2, as.numeric) # fix datatype
write.csv(df.truncations, file = 'OUTPUT/gene_truncated_stats.csv')
save(ls.complete_gene_MetaSeq
, df.truncations
, TRUNCATION_CUTOFF
, ALIGN_VS_REF_BIOSTRING
, ALIGN_VS_SELF_BIOSTRING
, file='OBJECTS/gene_trunc_stats.R')
}else{
load('OBJECTS/gene_trunc_stats.R')
}
temp.fileList
df.in
ref_aminos
ls.complete_gene_MetaSeq
+df.truncations
df.truncations
gene
ls.complete_gene_MetaSeq
names(ls.complete_gene_MetaSeq)
temp.fileDir
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/MASTER_IPCD-analysis.R')
fig1a
df.truncations
mean_dist
self_align
ref_aminos
sample(1:4, 200)
sample(1:4, 200, replace = T)
test.gene = paste(v.nucs(sample(1:4, 200, replace = T)))
v.mutFreqs = c(1e-5, 1e-4, 1e-3, 1e-2)
v.nucs = c('A', 'T', 'C', 'G')
test.gene = paste(v.nucs(sample(1:4, 200, replace = T)))
v.mutFreqs = c(1e-5, 1e-4, 1e-3, 1e-2)
v.nucs = c('A', 'T', 'C', 'G')
test.gene = paste(v.nucs[sample(1:4, 200, replace = T)], sep='')
test.gene
source('~/GitHub/Frequency_of_quorum_sensing_mutations_in_Pa2021/test_benchmark_distances.R')
test.gene
test.Aminos = translate(test.gene)
AAString()
AAString
AAstring(test.gene)
AAString(test.ami)
AAString(test.gene)
translate(AAString(test.gene))
?translate
DNAString(test.gene)
translate(DNAString(test.gene))
