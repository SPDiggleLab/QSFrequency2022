# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
head9df.gene
head(df.gene)
temp = df.gene[,c('GENE', 'HOST', 'SOURCE', 'ENV')]
head(temp)
temp[!temp$ENV]
temp[!temp$ENV,]
temp = temp[!temp$ENV,]
temp[is.na(temp$HOST),]
temp[is.na(temp$SOURCe),]
temp[is.na(temp$SOURCE),]
source('~/CYZ GITHUB/Digglets/For_Conan/analyze_seqs.R')
source('~/CYZ GITHUB/Digglets/For_Conan/MASTER_IPCD-analysis.R')
source('~/CYZ GITHUB/Digglets/For_Conan/plot_distance_pcas_by_gene.R')
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
fig2a = ggplot(df.lasR_meta, aes(x = TRUNCATED)) +
geom_bar(stat = 'count', color = 'black')
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
require(cowplot)
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
fig1_full
fig1_full = plot_grid(fig1a, fig1b, fig1c
, labels = c('A', 'B', 'C')
, nrow = 1
, rel_widths = c(1, 2, 2))
fig1_full
fig1_full = plot_grid(fig1a, fig1b, fig1c
, labels = c('A', 'B', 'C')
, nrow = 1
, rel_widths = c(1, 1.5, 1.5))
fig1_full
fig2_full = plot_grid(fig2a, fig2b, labels = c('A', 'B'))
fig2_full
fig2a = ggplot(df.lasR_meta, aes(x = GROUP, fill = TRUNCATED)) +
geom_bar(stat = 'count', color = 'black')
fig2a
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
fig2a
sum(df.lasR_meta$TRUNCATED)
# For Fig 2a
df.lasR_meta = ls.complete_gene_MetaSeq[['lasR']][,c('GENE', 'HOST', 'SOURCE', 'ENV', 'SEQUENCE')]
lasR_ref = read.table(paste('INPUT/ref_genes/lasR_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
# Add column: TRUNCATED
nBases_lasR = nchar(lasR_ref)*3
df.lasR_meta$TRUNCATED = sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x)<nBases_lasR})
df.lasR_meta$SEQUENCE = NULL # remove SEQ for easier reading
# If SOURCE is NA and HOST is HUMAN, assign source to non-CF
df.lasR_meta$SOURCE[(is.na(df.lasR_meta$SOURCE) & df.lasR_meta$HOST == 'Human')] = 'non-CF'
df.lasR_meta$SOURCE
df.lasR_meta$TRUNCATED
sum(df.lasR_meta$TRUNCATED)
sum(sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x)!=nBases_lasR}))
sum(as.vector(sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x)!=nBases_lasR})))
sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x)!=nBases_lasR})
df.lasR_meta = ls.complete_gene_MetaSeq[['lasR']][,c('GENE', 'HOST', 'SOURCE', 'ENV', 'SEQUENCE')]
lasR_ref = read.table(paste('INPUT/ref_genes/lasR_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
# Add column: TRUNCATED
nBases_lasR = nchar(lasR_ref)*3
df.lasR_meta$TRUNCATED = sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x) != nBases_lasR})
df.lasR_meta$SEQUENCE = NULL # remove SEQ for easier reading
sum(df.lasR_meta$TRUNCATED)
sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x)!=nBases_lasR})gene
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
lasR_ref
source('~/CYZ GITHUB/Digglets/For_Conan/visualize_data_overview.R')
for(gene in 'lasR'){#names(ls.refDist_by_gene)){
# Get Reference
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos = AAString(ref_aminos) # read in as biocstring object
# Calculate self-distance score
self_align = pairwiseAlignment(ref_aminos
, ref_aminos
, substitutionMatrix = "BLOSUM80"
, gapOpening=11
, gapExtension=1)@score
# normalize to self
v.dist = ls.refDist_by_gene[[gene]] / self_align
# get simple stats
mean_dist = mean(v.dist)
sd_dist = sd(v.dist)
df.truncations[gene, 'similarity_mean'] = mean_dist
df.truncations[gene, 'similarity_sd'] = sd_dist
}
df.truncations
v.dist
v.dist<1
sum(v.dist<1)
sum(v.dist<.99)
source('~/CYZ GITHUB/Digglets/For_Conan/parse_inputs.R')
ref_aminos_length = nchar(ref_aminos)
rm(list=ls())
## 04.11.2020 - CYZ
## This script analyzes the master table
require(Biostrings)
require(factoextra)
require(ape)
require(vegan)
TRUNCATION_CUTOFF = 0 #0 for all data. 1 for no truncations allowed.
# (0) Helpers -------------------------------------------------------------
ALIGN_VS_REF_BIOSTRING = function(REF=lasI_ref, ALL=lasI_all, gapOpen=11, gapExt=1){
ret = lapply(ALL, function(x){
return (pairwiseAlignment(REF
, x
, substitutionMatrix = "BLOSUM80"
, gapOpening=gapOpen
, gapExtension=gapExt)@score)
})
ret = do.call('rbind', ret)
return(ret)
}#test_ALIGN_VS_REF_BIOSTRING = ALIGN_VS_REF_BIOSTRING(ls.aastring_map[[1]], ls.aastring_map)
ALIGN_VS_SELF_BIOSTRING = function(ALL=lasI_all){
# to strings
v.seqs = unlist(lapply(ALL, as.character)) # char
v.seq_nos = names(ALL) # char
names(v.seqs) = v.seq_nos
nSeqs = length(v.seqs)
# find uniques
v.unique_seqs = v.seqs[!duplicated(v.seqs)]
# Reduce to unique AA sequences
ls_unique_seqs = ALL[names(v.unique_seqs)] # WARNING: the 'unique' function doesn't work with lists
# Calculate distances on AA sequences BIOSTRINGS
ls.uniqueAADist = lapply(ls_unique_seqs, function(x){
ret = ALIGN_VS_REF_BIOSTRING(x, ls_unique_seqs)
})
# Format distance matrix of unique AA sequences
df.uniqueAADist = do.call('cbind', ls.uniqueAADist)
colnames(df.uniqueAADist) = v.unique_seqs
rownames(df.uniqueAADist) = v.unique_seqs
# Format distance matrix of unique NT sequences
df.fullAADist = data.frame(matrix(rep(0, nSeqs^2), ncol = nSeqs))
colnames(df.fullAADist) = v.seq_nos
rownames(df.fullAADist) = v.seq_nos
# Fill distance matrix of unique NT sequences
for(i in 1:nSeqs){
for(j in 1:nSeqs){
i.seq = v.seqs[v.seq_nos[i]]
j.seq = v.seqs[v.seq_nos[j]]
if(!j.seq %in% v.unique_seqs){
print(j.seq)
}
df.fullAADist[i,j] = df.uniqueAADist[i.seq, j.seq]
}
}
return(df.fullAADist)
} #test_ALIGN_VS_SELF_BIOSTRING = ALIGN_VS_SELF_BIOSTRING(ls.aastring_map)
# (1) Load ----------------------------------------------------------------
# Get truncation statistics
# Find the most recent master table file
temp.fileList = list.files('OUTPUT/')
temp.fileDirs = temp.fileList[grep('_master-table.csv', temp.fileList)]
temp.fileDir = sort(temp.fileDirs, decreasing = T)[1]
# Read in sequence master table
df.in = read.table(paste('OUTPUT/', temp.fileDir, sep=''), header = T, sep=',', stringsAsFactors = F)
df.in = df.in[,c('STRAIN', 'GENE', 'HOST', 'SOURCE', 'ENV', 'PI'
, 'SEQUENCE' , 'MISMATCH', 'GAPS', 'PCT_ID', 'QUERY_COV', 'BIT_SCORE', 'E.VALUE'
, 'INCLUDE')]
rm(temp.fileList, temp.fileDirs, temp.fileDir)
# Fill in Blanks
df.in[df.in==''] = NA
# Split by gene
ls.in = split(df.in, df.in$GENE)
ls.truncations = list()
ls.complete_gene_MetaSeq = list()
gnee = 'lasR'
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
# Get number of truncations by translating.
gene = 'lasR'
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
# Get number of truncations by translating.
ref_aminos_length
df.gene$SEQUENCE
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
# Get AAs
v.seqAAs = sapply(df.gene$SEQUENCE
, function(x){translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T)})
v.seqAAs
v.seqAAs[1]
as.character(v.seqAAs[1])
(v.seqAAs[1]$seq
)
v.seqAAs[1]@seq
v.seqAAs[1]$ATGGCCTTGGTTGACGGTTTTCTTGAGCTGGAACGCTCAAGTGGAAAATTGGAGTGGAGCGCCATCCTGCAGAAGATGGCGAGCGACCTTGGATTCTCGAAGATCCTGTTCGGCCTGTTGCCTAAGGACAGCCAGGACTACGAGAACGCCTTCATCGTCGGCAACTACCCGGCCGCCTGGCGCGAGCATTACGACCGGGCTGGCTACGCGCGGGTCGACCCGACGGTCAGTCACTGTACCCAGAGCGTACTGCCGATTTTCTGGGAACCGTCCATCTACCAGACGCGAAAGCAGCACGAGTTCTTCGAGGAAGCCTCGGCCGCCGGCCTGGTGTATGGGCTGACCATGCCGCTGCATGGTGCTCGCGGCGAACTCGGCGCGCTGAGCCTCAGCGTGGAAGCGGAAAACCGGGCCGAGGCCAACCGTTTCATGGAGTCGGTCCTGCCGACCCTGTGGATGCTCAAGGACTACGCACTGCAGAGCGGTGCCGGACTGGCCTTCGAACATCCGGTCAGCAAACCGGTGGTTCTGACCAGCCGGGAGAAGGAAGTGTTGCAGTGGTGCGCCATCGGCAAGACCAGTTGGGAGATATCGGTTATCTGCAACTGCTCGGAAGCCAATGTGAACTTCCATATGGGAAATATTCGGCGGAAGTTCGGTGTGACCTCCCGCCGCGTAGCGGCCATTATGGCCGTTAATTTGGGTCTTATTACTCTCTGA
name(v.seqAAs)
names(v.seqAAs)
unlist(v.seqAAs)
getSeq(v.seqAAs)
getSeq(v.seqAAs[1])
getSeq(v.seqAAs[[1]])
v.seqAAs[[1]]
str(v.seqAAs[[1]])
v.seqAAs[[1]]]$seq
v.seqAAs[[1]]]@seq
alphabetFrequency(v.seqAAs[[1]])
# Get AAs
v.seqAAs = sapply(df.gene$SEQUENCE, function(x){toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))})
v.seqAAs
v.seqAAs[1]
test = vseqAAs[1]
head(test)
test
test = v.seqAAs[1]
test
strsplit(test, '*')
strsplit(test, '\*')
strsplit(test, '\\*')
strsplit(test, '\\*')[[1]]
nchar(strsplit(test, '\\*')[[1]])
rm(list=ls())
## 04.11.2020 - CYZ
## This script analyzes the master table
require(Biostrings)
require(factoextra)
require(ape)
require(vegan)
TRUNCATION_CUTOFF = 0 #0 for all data. 1 for no truncations allowed.
# (0) Helpers -------------------------------------------------------------
ALIGN_VS_REF_BIOSTRING = function(REF=lasI_ref, ALL=lasI_all, gapOpen=11, gapExt=1){
ret = lapply(ALL, function(x){
return (pairwiseAlignment(REF
, x
, substitutionMatrix = "BLOSUM80"
, gapOpening=gapOpen
, gapExtension=gapExt)@score)
})
ret = do.call('rbind', ret)
return(ret)
}#test_ALIGN_VS_REF_BIOSTRING = ALIGN_VS_REF_BIOSTRING(ls.aastring_map[[1]], ls.aastring_map)
ALIGN_VS_SELF_BIOSTRING = function(ALL=lasI_all){
# to strings
v.seqs = unlist(lapply(ALL, as.character)) # char
v.seq_nos = names(ALL) # char
names(v.seqs) = v.seq_nos
nSeqs = length(v.seqs)
# find uniques
v.unique_seqs = v.seqs[!duplicated(v.seqs)]
# Reduce to unique AA sequences
ls_unique_seqs = ALL[names(v.unique_seqs)] # WARNING: the 'unique' function doesn't work with lists
# Calculate distances on AA sequences BIOSTRINGS
ls.uniqueAADist = lapply(ls_unique_seqs, function(x){
ret = ALIGN_VS_REF_BIOSTRING(x, ls_unique_seqs)
})
# Format distance matrix of unique AA sequences
df.uniqueAADist = do.call('cbind', ls.uniqueAADist)
colnames(df.uniqueAADist) = v.unique_seqs
rownames(df.uniqueAADist) = v.unique_seqs
# Format distance matrix of unique NT sequences
df.fullAADist = data.frame(matrix(rep(0, nSeqs^2), ncol = nSeqs))
colnames(df.fullAADist) = v.seq_nos
rownames(df.fullAADist) = v.seq_nos
# Fill distance matrix of unique NT sequences
for(i in 1:nSeqs){
for(j in 1:nSeqs){
i.seq = v.seqs[v.seq_nos[i]]
j.seq = v.seqs[v.seq_nos[j]]
if(!j.seq %in% v.unique_seqs){
print(j.seq)
}
df.fullAADist[i,j] = df.uniqueAADist[i.seq, j.seq]
}
}
return(df.fullAADist)
} #test_ALIGN_VS_SELF_BIOSTRING = ALIGN_VS_SELF_BIOSTRING(ls.aastring_map)
# (1) Load ----------------------------------------------------------------
# Find the most recent master table file
temp.fileList = list.files('OUTPUT/')
temp.fileDirs = temp.fileList[grep('_master-table.csv', temp.fileList)]
temp.fileDir = sort(temp.fileDirs, decreasing = T)[1]
# Read in sequence master table
df.in = read.table(paste('OUTPUT/', temp.fileDir, sep=''), header = T, sep=',', stringsAsFactors = F)
df.in = df.in[,c('STRAIN', 'GENE', 'HOST', 'SOURCE', 'ENV', 'PI'
, 'SEQUENCE' , 'MISMATCH', 'GAPS', 'PCT_ID', 'QUERY_COV', 'BIT_SCORE', 'E.VALUE'
, 'INCLUDE')]
rm(temp.fileList, temp.fileDirs, temp.fileDir)
# Fill in Blanks
df.in[df.in==''] = NA
# Split by gene
ls.in = split(df.in, df.in$GENE)
ls.truncations = list()
ls.complete_gene_MetaSeq = list()
gene = 'lasR'
# load Ref
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos_length = nchar(ref_aminos)
# query gene data
df.gene = ls.in[[gene]]
# How many genes pass quality filter?
n.allGenes = nrow(df.gene)
# Must have: PI, (ENV|(SOURCE|HOST))
b.noENV = is.na(df.gene$ENV) # envcan't be NA
b.noPI = is.na(df.gene$PI)
df.error = df.gene[b.noENV | b.noPI,]
df.gene = df.gene[!(b.noENV | b.noPI),]
# If Not ENV, must have SOURCE|HOST
b.ENV = df.gene$ENV
b.noSOURCE = is.na(df.gene$SOURCE)
b.noHOST = is.na(df.gene$HOST)
df.gene = df.gene[(b.ENV|!(b.noSOURCE&b.noHOST)),]
# Remove entries that do not start with 'ATG'
b.atg = sapply(df.gene$SEQUENCE, function(x){substr(x, 1, 3)!='ATG'})
df.error = rbind(df.error, df.gene[b.atg,])
df.gene = df.gene[!b.atg,]
# Remove entries with '-' gaps
b.gaps = grepl('-', df.gene$SEQUENCE)
n.gaps = sum(b.gaps)
df.error = rbind(df.error, df.gene[b.gaps,])
df.gene = df.gene[!b.gaps,]
# Calculate reference gene length
gene_length = nchar(ref_aminos)*3 # protein sequence * 3
# Get the number of genes used in the analysis
n.genes = nrow(df.gene)
# Get the number of unique strains/seqs used in the analysis
n.unique_strains = n.genes - sum(duplicated(df.gene$STRAIN))
n.unique_sequences = n.genes - sum(duplicated(df.gene$SEQUENCE))
# Get AAs
b.truncs = sapply(df.gene$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return(nchar(strsplit(seqDNA, '\\*')[[1]])<239)
})
b.truncs
rm(list=ls())
require(ggplot2)
require(reshape2)
require(Biostrings)
# Load Data
load('OBJECTS/gene_trunc_stats.R')
load('OBJECTS/list_of_strain_distMats_by_gene.R')
load('OBJECTS/PCA_VIZ.R')
df.truncations$similarity_mean = NA
df.truncations$similarity_sd = NA
for(gene in 'lasR'){#names(ls.refDist_by_gene)){
# Get Reference
ref_aminos = read.table(paste('INPUT/ref_genes/', gene, '_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
ref_aminos = AAString(ref_aminos) # read in as biocstring object
# Calculate self-distance score
self_align = pairwiseAlignment(ref_aminos
, ref_aminos
, substitutionMatrix = "BLOSUM80"
, gapOpening=11
, gapExtension=1)@score
# normalize to self
v.dist = ls.refDist_by_gene[[gene]] / self_align
# get simple stats
mean_dist = mean(v.dist)
sd_dist = sd(v.dist)
df.truncations[gene, 'similarity_mean'] = mean_dist
df.truncations[gene, 'similarity_sd'] = sd_dist
}
# For Fig 2a
df.lasR_meta = ls.complete_gene_MetaSeq[['lasR']][,c('GENE', 'HOST', 'SOURCE', 'ENV', 'SEQUENCE')]
lasR_ref = read.table(paste('INPUT/ref_genes/lasR_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
df.lasR_meta
# Get AAs
b.truncs = sapply(df.lasR_meta$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return(nchar(strsplit(seqDNA, '\\*')[[1]])<239)
})
nBases_lasR = nchar(lasR_ref)*3
df.lasR_meta$TRUNCATED = b.truncs#sapply(df.lasR_meta$SEQUENCE, function(x){nchar(x) < nBases_lasR})
df.lasR_meta$SEQUENCE = NULL # remove SEQ for easier reading
sum(df.lasR_meta$TRUNCATED)
b.truncs
# Get AAs
b.truncs = sapply(df.lasR_meta$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return(nchar(strsplit(seqDNA, '\\*')[[1]][1])<239)
})
b.truncs
# Get AAs
b.truncs = sapply(df.lasR_meta$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return((nchar(strsplit(seqDNA, '\\*')[[1]])<239)[1])
})
b.truncs
test = 'asdf*asd'
gregexpr('\\*', test)
gregexpr('\\*', test)[[1]]
gregexpr('\\*', test)[[1]][1]
# Get AAs
b.truncs = sapply(df.lasR_meta$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return(gregexpr('\\*', seqDNA)[[1]][1] == nchar(lasR_ref))
})
b.truncs
df.lasR_meta$SEQUENCE
# For Fig 2a
df.lasR_meta = ls.complete_gene_MetaSeq[['lasR']][,c('GENE', 'HOST', 'SOURCE', 'ENV', 'SEQUENCE')]
lasR_ref = read.table(paste('INPUT/ref_genes/lasR_PAO1_protein.txt', sep='', collapse='')
, stringsAsFactors = F)$V1
# Get AAs
b.truncs = sapply(df.lasR_meta$SEQUENCE, function(x){
seqDNA = toString(translate(DNAString(x), if.fuzzy.codon = c('solve', 'X'), no.init.codon = T))
return(gregexpr('\\*', seqDNA)[[1]][1] == nchar(lasR_ref))
})
b.truncs
names(b.truncs) == NULL
b.truncs
b.truncs
unlist(b.truncs)
as.vector(b.truncs)
